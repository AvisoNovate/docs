<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>io.aviso.toolchest.macros documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Toolchest</span> <span class="project-version">0.1.4</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aviso</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>toolchest</span></div></div></li><li class="depth-4 branch"><a href="io.aviso.toolchest.collections.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>collections</span></div></a></li><li class="depth-4 branch"><a href="io.aviso.toolchest.exceptions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exceptions</span></div></a></li><li class="depth-4 branch current"><a href="io.aviso.toolchest.macros.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>macros</span></div></a></li><li class="depth-4 branch"><a href="io.aviso.toolchest.metadata.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>metadata</span></div></a></li><li class="depth-4 branch"><a href="io.aviso.toolchest.testing.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>testing</span></div></a></li><li class="depth-4 branch"><a href="io.aviso.toolchest.threads.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>threads</span></div></a></li><li class="depth-4"><a href="io.aviso.toolchest.vars.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>vars</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="io.aviso.toolchest.macros.html#var-cond-let"><div class="inner"><span>cond-let</span></div></a></li><li class="depth-1"><a href="io.aviso.toolchest.macros.html#var-consume"><div class="inner"><span>consume</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">io.aviso.toolchest.macros</h1><div class="doc"><div class="markdown"><p>Generally useful macros for prettier and more expressive code.</p></div></div><div class="public anchor" id="var-cond-let"><h3>cond-let</h3><h4 class="type">macro</h4><div class="usage"><code>(cond-let &amp; forms)</code></div><div class="doc"><div class="markdown"><p>A merging of cond and let. Each term is either a vector (in which case, it acts like let) or a condition expression followed by the value for that expression. An empty cond-let returns nil.</p>
<p>cond-let makes it possible to create readable code that doesnâ€™t end up nesting ;endlessly.</p>
<p>A typical example is where several steps must occur, perhaps reading data from an external datastore and making a few consistency checks:</p>
<pre><code>(defn apply-payment [db-conn order-id user-id payment-info]
  (cond-let
    [order (find-order-by-id db-conn order-id)]

    (nil? order)
    not-found-response

    (not (owned-by? order user-id))
    forbidden-response

    [existing-payment (find-payment db-conn (:payment-id order))]

    (some? existing-payment)
    already-payed-response

    :else
    (do
      (attach-payment db-conn order payment-info)

      updated-response)))
</code></pre></div></div><div class="src-link"><a href="https://github.com/AvisoNovate/toolchest/blob/master/src/io/aviso/toolchest/macros.clj#L4">view source</a></div></div><div class="public anchor" id="var-consume"><h3>consume</h3><h4 class="type">macro</h4><div class="usage"><code>(consume coll bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Consume is used to break apart a collection into individual terms.</p>
<p>The format is:</p>
<pre><code>(consume coll [symbol predicate arity ...] body)
</code></pre>
<p>The symbol is assigned a value by extracting zero or more values from the collection that match the predicate. The predicate is passed a single element from the collection and should return a truth value.</p>
<p>The arity is a keyword that identifies how many values are taken from the collection.</p>
<dl>
  <dt>:one
  </dt>
  <dd>The first value in the collection must match the predicate, or an exception is thrown.  The value is assigned to the symbol. The literal value 1 may be used instead of :one.</dd>
  <dt>:?
  </dt>
  <dd>Matches 0 or 1 values from the collection. If the first value does not match the predicate,  then nil is assigned to the symbol.</dd>
  <dt>:*
  </dt>
  <dd>Zero or more values from the collection are assigned to the symbol. The symbol may be assigned  an empty collection.</dd>
  <dt>:+
  </dt>
  <dd>Matches one or more values; an exception is thrown if there are no matches.</dd>
</dl>
<p>The symbol/pred/arity triplet can be followed by additional triplets.</p>
<p>Although the above description discusses triplets, there are two special predicate values that are used as just a pair (symbol followed by special predicate), with no arity.</p>
<dl>
  <dt>:&amp;
  </dt>
  <dd>Used to indicate consumption of all remaining values, if any, from the collection.  It is not followed by an arity, and must be the final term in the bindings vector.</dd>
  <dt>:+
  </dt>
  <dd>Used to consume a single value always (throwing an exception if the collection is  empty).</dd>
</dl>
<p>consume expands into a let form, so the symbol in each triplet may be a destructuring form.</p>
<p>As an example, a function that expects an optional map followed by at least one string, followed by any number of vectors:</p>
<pre><code>(defn example
  {:arglists '([options strings... &amp; vectors] [strings... &amp; vectors])}
  [&amp; args]
  (consume args
    [options map? :?       ; nil or a map
     strings string? :+    ; seq of strings, at least one
     vectors :&amp;]           ; remaining arguments, may be empty
     ;; Use options, strings, vectors here
     ...))
</code></pre></div></div><div class="src-link"><a href="https://github.com/AvisoNovate/toolchest/blob/master/src/io/aviso/toolchest/macros.clj#L46">view source</a></div></div></div></body></html>